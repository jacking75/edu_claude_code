# Claude Code Agent Teams — 화이트보드 패턴으로 "분업"을 "협업"으로 바꾸기

[출처](https://zenn.dev/happy_elements/articles/da2dda3618425c ) 
   
---

## **핵심 문제의식:**
Claude Code Agent Teams에서 동일한 분석 태스크를 두 가지 구성으로 실행했다. 1회차는 기본 구성으로 2명의 에이전트를 병렬 실행했다. 결과는 **2개의 완성도 높은 독립 리포트**였지만, 두 리포트 어디에도 서로의 내용을 참조한 기술이 없었다. 2회차는 **리더가 공유 Markdown 파일(화이트보드)을 하나 준비한 것만** 다르다. 결과는 완전히 달라졌다.

| 관점 | 1회차 - 기본 구성 | 2회차 - 화이트보드 있음 |
|------|------------------|------------------------|
| 상호 참조 | 없음 | Agent B가 Agent A의 발견을 명시적으로 참조·검증 |
| 횡단적 인사이트 | 0건 | 4건의 횡단적 관찰 출현 |
| 용어 통일 | 각자 독자적 용어 사용 | Agent A의 용어를 B가 이어받음 |
| 검증 행동 | 없음 | Agent A의 예측을 B가 4건 중 4건 검증 |
| 성과물의 성격 | **2개의 독립 리포트** | **1개의 통합 분석** |

SendMessage(Agent Teams 표준 메시지 기능)는 "대화"이고, 화이트보드는 "공유 지식"이다. **화이트보드가 팀워크를 촉진하는 것은 인간도 AI도 마찬가지다.**

---

## **실험 상세:**

**태스크 설계**: Next.js App Router 아키텍처 베스트 프랙티스 분석. Agent A(라우팅·데이터 페칭 담당) + Agent B(퍼포먼스 최적화 담당).

| | Case 1: 기본 구성 | Case 2: 화이트보드 있음 |
|--|-------------------|------------------------|
| 구조 | Agent A, B (독립 병렬 실행) | 리더가 화이트보드 생성 → Agent A 실행·기록 → Agent B 실행 |
| 공유 정보 | 없음 | 화이트보드에 기록된 발견 사항 |
| 실행 순서 | 병렬 | 순차 (A의 지식을 B가 참조) |

**Case 1의 문제**: Agent A는 Server Component의 `fetch`, `generateStaticParams`, Parallel Routes 등을 망라적으로 분석했다. Agent B는 이미지 최적화, `next/font`, PPR 등 퍼포먼스를 상세히 정리했다. 두 리포트 모두 각자의 영역에서는 완결되어 있지만, Agent A는 캐시 전략과의 관계에 언급하지 않았고, Agent B는 어떤 데이터 페칭 패턴과 조합해야 하는지를 언급하지 않았다.

**Case 2에서 일어난 일**: Agent A가 화이트보드에 작성한 내용에 이런 섹션이 자발적으로 출현했다.

```markdown
### Agent B에 대한 인수인계 (퍼포먼스에 영향을 줄 것 같은 설계 결정)
- Next.js 15 이후, fetch는 기본적으로 비캐시 → 명시적으로 `cache: 'force-cache'` 지정 필요
- fetch는 layout/page/generateMetadata 간 자동으로 중복 제거됨 (Request Memoization)
- generateStaticParams로 프리렌더링된 페이지 → 빌드 시 캐시 완료
- Parallel Routes (@folder)는 독립적으로 스트리밍 가능 → loading.tsx 배치가 핵심
```

Agent A는 **자신의 담당 범위를 넘어, Agent B의 작업에 도움이 될 것 같은 예측을 기록했다.** Agent B는 이 화이트보드를 읽고 나서 분석을 시작했고, Case 1에는 없었던 다음 섹션들이 출현했다.

```markdown
### Agent A의 데이터 페칭 설계 → 퍼포먼스 영향
- Next.js 15 기본 비캐시 → revalidate 값이 TTFB에 직결
- fetch의 Request Memoization → 동일 렌더링 패스 내에서 자동으로 1회로 통합. ORM 등은 React cache()로 명시적 메모화 필요
- Parallel Routes + Suspense → 각 @slot이 독립 스트리밍 가능. 가장 느린 slot이 LCP 결정

### Agent A가 예측한 설계 결정 — 퍼포먼스 검증 결과
- fetch 기본 비캐시 → ✅ 확인. `use cache` 디렉티브로 명시적 캐시 가능
- fetch 중복 제거 → ✅ 확인. layout/page/generateMetadata 간 기능 확인
- generateStaticParams → ✅ 빌드 시 캐시 확인. dynamicParams: false로 미생성 페이지 404화 가능
- Parallel Routes + streaming → ✅ 확인. error.tsx 배치로 개별 에러 경계 필요
```

또한 Case 1에는 존재하지 않았던 **"횡단적 관찰" 섹션**도 생성되었다.

```markdown
## Cross-Cutting Observations
1. fetch 캐시 전략은 "데이터 페칭 설계"와 "퍼포먼스" 양쪽 문맥에서 이해해야 한다 — 한쪽만으로는 설계 판단을 잘못 내릴 수 있다
2. layout.tsx는 "라우팅 구조"임과 동시에 "캐시 경계"이기도 하다
3. Suspense boundary 배치는 라우팅 설계와 Core Web Vitals 양쪽을 고려해야 한다
4. Route Segment Config (dynamic, revalidate)는 데이터 페칭 설계와 퍼포먼스 튜닝의 접점이다
```

---

## **화이트보드 패턴 — 5분 만에 시험해볼 수 있는 템플릿:**
화이트보드 패턴은 **팀 멤버가 읽고 쓸 수 있는 공유 Markdown 파일**을 하나 배치하는 접근이다. Agent Teams의 표준 기능이 아닌, 리더의 프롬프트에 삽입하는 패턴이다.

```
리더가 화이트보드 생성 → Agent A 실행·기록 → Agent B가 읽고 나서 실행
```

이번 실험에서는 A → B의 순차 실행이었지만, B → A 순서나 양쪽이 병렬로 화이트보드를 공유하는 구성도 가능하다. 리더의 프롬프트에 바로 삽입할 수 있는 템플릿은 다음과 같다.

```markdown
# Whiteboard: {토픽}

## Goal
{팀이 최종적으로 답해야 할 질문}

## Team Structure
- Agent A: {담당 영역}
- Agent B: {담당 영역}

## How Our Work Connects
{두 사람의 작업 연결점을 명시}

## Key Questions
1. {양쪽 관점이 필요한 질문}
2. {양쪽 관점이 필요한 질문}
3. {양쪽 관점이 필요한 질문}

---

## Agent A Findings
（Agent A: 여기에 기록）

## Agent B Findings
（Agent B: 여기에 기록）

## Cross-Cutting Observations
（누구든: 횡단적 관찰을 기록）
```

포인트는 세 가지다. **목표 명시**(무엇을 위해 분석하는가), **연결점 명시**(두 사람의 작업이 어떻게 이어지는가), **기록란의 구조화**(각 에이전트가 기록하는 공간과 횡단적 관찰을 위한 공유 공간).

---

## **왜 이것으로 달라지는가:**

**Agent Teams의 기본 구성 — 실제로는 공유되지 않는다**

Agent Teams 내에서 공유되는 것과 공유되지 않는 것을 정리하면 다음과 같다.

| | 공유됨? | 구조 |
|--|---------|------|
| 대화 이력 | ❌ 안 됨 | 각 에이전트는 독립된 컨텍스트 윈도우 |
| 발견 사항 | ❌ 자동으로는 공유 안 됨 | SendMessage로 명시적으로 전달 필요 |
| 태스크 리스트 | ✅ 공유됨 | 전원이 TaskList/TaskUpdate로 읽고 쓸 수 있음 |
| 파일 시스템 | ⚠️ 읽고 쓰기 가능 | 팀메이트 권한 설정에 따라 쓰기 제한 가능 |

공식 문서에도 각 에이전트는 독립된 컨텍스트 윈도우를 가지며 대화 이력은 공유되지 않는다고 명기되어 있다. **표준 정보 공유 수단은 SendMessage와 태스크 리스트뿐**이다.

**인간 팀에서도 같은 일이 일어난다**

Slack으로 메시지를 주고받는 것만으로는 팀은 "분업"에 머문다. 회의실 화이트보드에 목표와 진행 상황을 기록한 순간 멤버의 움직임이 달라진다. 팀 연구 분야에서는 이를 **"공유 멘탈 모델"** 이라고 부른다. 팀 멤버가 같은 전체상을 가짐으로써, 명시적인 지시 없이도 서로의 행동을 예측하고 조정할 수 있게 된다는 개념이다.

화이트보드가 수행하는 역할을 정리하면 다음과 같다.

| 하는 것 | 효과 |
|---------|------|
| 목표와 연결점을 기록 | 팀 전체의 목적과, 자신의 작업이 다른 멤버에게 어떤 영향을 주는지 보임 |
| 파일을 전원과 공유 | 서로 다른 전문 영역 사이를 잇는 공유물이 됨 |
| 팀 구성을 명시 | "누가 무엇을 담당하는가"가 명확해져, 상대방의 작업을 의식한 행동이 생겨남 |

**이 아이디어의 선행 연구**

이 접근에는 선행 연구가 있다. 1986년 Nii가 제창한 **Blackboard Architecture**는 여러 에이전트가 공유 지식 베이스에 읽고 쓰며 협조하는 아키텍처다. 2025년 연구(Han & Zhang)에서는 이 아키텍처를 LLM 멀티에이전트 시스템에 적용한 결과, **정적 멀티에이전트 시스템과 동등 이상의 성능**을 달성하면서 **토큰 소비량도 대폭 절감**할 수 있었다고 보고되었다. Agent Teams에서의 "화이트보드"는 이 Blackboard Architecture의 경량 구현으로 볼 수 있다.

---

## **실천 — 사용 구분과 주의점:**

**언제 사용하는가**

| 실행 방식 | 적합한 태스크 |
|-----------|--------------|
| 병렬 (화이트보드 없음) | 완전히 독립된 태스크 |
| 병렬 (화이트보드 있음) | 목표 공유만으로 충분한 케이스 |
| 순차 (화이트보드 있음) | 앞 에이전트의 발견이 뒤의 작업에 영향을 주는 케이스 |

**언제 사용하지 않는가**

화이트보드가 항상 최선은 아니다. 완전히 독립된 태스크(별도 리포지토리 변경 등 공유 컨텍스트가 없는 작업)는 화이트보드를 배치해도 읽을 이유가 없어 오버헤드만 된다. "테스트를 작성한다"와 "문서를 작성한다"처럼 접점이 적은 단순 병렬 실행은 SendMessage로 충분하다. **3명 이상의 팀**에서는 화이트보드 구조가 복잡해져 오히려 혼란을 초래할 수 있다. 이 경우 역할별로 섹션을 나누거나 여러 화이트보드로 분할하는 방법이 필요하다.

**리더의 역할 변화**

화이트보드 패턴에서는 리더의 역할이 바뀐다. 팀메이트는 파일 쓰기 권한이 제한될 수 있으므로, **리더가 팀메이트의 발견 사항을 화이트보드에 옮겨 기록**해야 한다. 이는 인간 팀에서의 리더와 같은 역할이다. 회의에서 화이트보드에 요점을 정리하는 퍼실리테이터, Slack에서 중요한 논의를 정리해 게시하는 매니저와 하는 일이 동일하다. **리더의 작업은 "작업 지시"가 아니라 "지식의 퍼실리테이션"이 된다.**

**왜 파일인가**

| 방식 | 구조화 | 영속성 | 팀메이트가 쓸 수 있는가 |
|------|--------|--------|------------------------|
| Markdown 파일 | ✅ | ✅ 디스크에 남음 | ⚠️ 리더가 업데이트 |
| SendMessage 릴레이 | ❌ 텍스트만 | ❌ 대화에 묻힘 | — |
| 태스크 리스트 | △ 타이틀+설명 | △ 팀 해산 시 삭제 | ✅ 전원 가능 |

파일의 최대 강점은 **영속성**이다. 대화가 끝난 후에도 파일은 남는다. 화이트보드는 "코디네이션 툴"임과 동시에 "팀의 성과물"이기도 하다. 이 이중 역할이 파일 기반의 강점이다.

---

## **요약:**
Agent Teams에서 역할을 나누는 것만으로는 "분업"에 불과하다. 화이트보드를 배치하면 "협업"으로 바뀐다.

- **목표와 연결점을 공유한다** — 각 에이전트가 전체상을 의식할 수 있다
- **발견 사항을 축적한다** — 앞 에이전트의 지식이 다음 에이전트의 출발점이 된다
- **횡단적 인사이트가 생겨난다** — 독립 작업에서는 나오지 않는, 영역을 넘은 발견이 출현한다

화이트보드는 Agent Teams의 표준 기능이 아니라, Markdown 파일 하나로 실현할 수 있는 단순한 패턴이다.  


<br/>  
<br/>  
  

# Claude Code Agent Teams — 화이트보드 지시 방법

**기본 원리:**  
화이트보드 기능은 Claude Code의 별도 기능이 아니다. **리더 에이전트의 프롬프트에 공유 Markdown 파일 생성과 읽기/쓰기 규칙을 직접 지시하는 패턴**이다. 별도 설정 없이 프롬프트만으로 동작한다.  
  
---

## **방법 1 — 가장 단순한 지시 (즉시 사용 가능)**

```
다음 작업을 Agent Teams로 실행해줘.

먼저 `whiteboard.md` 파일을 생성하고, 아래 구조로 초기화해줘:

# Whiteboard: {작업 주제}

## Goal
{팀이 최종적으로 답해야 할 목표}

## Team Structure
- Agent A: {담당 영역}
- Agent B: {담당 영역}

## How Our Work Connects
{두 에이전트의 작업이 어떻게 연결되는지}

---

## Agent A Findings
（Agent A가 여기에 발견 사항을 기록）

## Agent B Findings
（Agent B가 여기에 발견 사항을 기록）

## Cross-Cutting Observations
（어느 쪽이든: 양쪽 영역에 걸친 횡단적 관찰을 기록）

---

실행 순서:
1. 리더가 whiteboard.md를 생성한다
2. Agent A가 자신의 담당 작업을 실행하고, 결과와 Agent B에 대한 인수인계 사항을 whiteboard.md에 기록한다
3. Agent B는 반드시 whiteboard.md를 읽은 뒤 작업을 시작하고, Agent A의 발견을 참조·검증하며 결과를 기록한다
4. 리더가 whiteboard.md를 읽고 최종 통합 리포트를 출력한다
```

---

## **방법 2 — CLAUDE.md에 영구 규칙으로 등록 (매번 지시 불필요)**
프로젝트 루트 또는 `~/.claude/CLAUDE.md`에 아래를 추가하면, Agent Teams를 사용할 때마다 자동으로 화이트보드 패턴이 적용된다.

```markdown
## Agent Teams 화이트보드 규칙

Agent Teams로 작업할 때는 반드시 다음 규칙을 따른다:

1. **화이트보드 파일 생성**: 작업 시작 전 리더가 `whiteboard.md`를 생성한다
2. **구조 준수**: Goal / Team Structure / How Our Work Connects / 
   각 에이전트 Findings / Cross-Cutting Observations 섹션을 반드시 포함한다
3. **순차 실행 원칙**: 후속 에이전트는 반드시 whiteboard.md를 읽은 뒤 작업을 시작한다
4. **인수인계 필수**: 각 에이전트는 자신의 발견 사항뿐 아니라 
   다음 에이전트에게 유용한 예측·주의사항도 기록한다
5. **생 데이터 금지**: 수치나 기술적 중간 과정은 기록하지 않는다. 
   의미 있는 발견과 판단만 기록한다
6. **리더의 역할**: 팀메이트의 쓰기 권한이 제한될 경우, 
   리더가 팀메이트의 발견 사항을 whiteboard.md에 대신 옮겨 기록한다
```

---

## **방법 3 — 실제 작업에 바로 적용하는 프롬프트 예시**
예를 들어 코드 리뷰를 시킬 때는 다음처럼 지시한다.

```
이 리포지토리를 Agent Teams로 리뷰해줘.

whiteboard.md를 먼저 만들고:
- Agent A: 보안·취약점 관점에서 리뷰
- Agent B: 성능·최적화 관점에서 리뷰

Agent A가 먼저 작업하고 whiteboard.md에 결과를 기록할 때,
"Agent B에 대한 인수인계" 섹션도 꼭 포함해줘.
(예: 보안 이슈 중 성능에도 영향을 줄 수 있는 것들)

Agent B는 whiteboard.md를 읽고 나서 작업을 시작하고,
Agent A의 발견을 검증하거나 보완한 내용도 기록해줘.

마지막에 리더가 whiteboard.md를 바탕으로 우선순위가 붙은 통합 리포트를 출력해줘.
```

---

## **핵심 포인트 3가지:**

- **"whiteboard.md를 먼저 생성해줘"** 라고 명시적으로 지시하는 것이 가장 중요하다. 이 한 줄이 없으면 에이전트는 그냥 병렬로 독립 실행한다
- **"Agent B는 반드시 whiteboard.md를 읽은 뒤 작업을 시작해"** 라는 순서 지시가 핵심이다. 이것이 있어야 상호 참조와 검증이 일어난다
- **"Agent B에 대한 인수인계 섹션을 포함해"** 라고 지시하면, Agent A가 자신의 담당 범위를 넘어 Agent B에게 유용한 예측을 자발적으로 기록하게 된다